# gof-learn
> 本项目为本人阅读《Head First设计模式》学习过程代码与时间线个人感想与练习代码记录

## 引言
 2019.4.8号开始阅读，首先这本书给我第一感觉是非常nice的，有种相见恨晚的感觉，自己是一个很容易走神的人，
 所以这本书是非常适合我，目前在看完第一章，用上我的蕃茄时间，书上描述+配图，没有学习压力，简单看懂。
 现在就是告诫自己不要急，慢慢来，把书看完，争取最大程度上的接受与吸收。保持一天学一个设计模式的节奏。

## oo基础
1. 抽象
2. 封装
3. 多态
4. 继承

## oo原则
1. 封装变化
2. 多用组合，少用继承
3. 针对接口编程，不针对实现编程
4. 为交互对象之间的松耦合设计而努力
5. 对扩展开放，对修改关闭
6. 依赖抽象，不要依赖具体类

## oo模式

### 策略模式
> 定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
#### 个人看法
当一个类有多种形态时，且每
#### 使用场合
1.出现有许多相关的类,仅仅是行为有差别的情况下,可以使用策略模式来使用多个行为中的一个来配置一个类的方法,实现算法动态切换  
2.出现同一算法,有很多不同实现的情况下,可以使用策略模式来把这些"不同的实现"实现成为一个算法的类层次. 
3.需要封装算法中,有与算法相关数据的情况下,可以使用策略模式来避免暴露这些跟算法相关的数据结构.  
4.出现抽象一个定义了很多行为的类,并且是通过多个if-else语句来选择这些行为的情况下,可以使用策略模式来替换这些条件语句.


---    
### 观察者模式
> 定义了对象之间的一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新；
#### 使用场合
1.当一个抽象模型有两个方面,其中一个方面的操作依赖于另一个方面的状态变化,那么就可以选用观察者模式,将这两者封装成观察者和目标对象,当目标对象变化的时候,依赖于它的观察者对象也会发生相应的变化.这样就把抽象模型的这两个方面分离了使得,它们可以独立地改变和复用.  
2.如果在更改一个对象的时候,需要同时连带改变其他对象,而且不知道究竟应该有多少对象需要被连带改变,这种情况可以选用观察者模式,被改的那一个对象很明显就相当于是目标对象,而需要连带修改的对歌其他对象,就作为多个观察着对象了.  
3.当一个对象必须通知其他的对象,但是你又希望这个对象和其他被它通知的对象是松散耦合的,也就是说这个对象其实不详知道具体被通知的对象.这种情况可以选用观察者模式,这个对象就相当于是目标对象,而被它通知的对象就是观察者对象了.
#### 个人看法
是一种订阅通知模型，经典的事件模型就用了此观察者模式 
#### 总结      
1. 此模式，可从被观察者处推或拉取数据（然而，推的方式 被认为更正确），个人认为有各自有各自的优缺点。
2. 有多个观察者时，不可以依赖特定的通知次序。
3. java有多种观察者模式的实现，包括了能用的java.util.Observable
4. 要注意java.util.Observable实现上会带来一些问题，observable是一个类

---
### 装饰者模式
> 动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
#### 使用场合  
1.如果需要在不影响其他对象的情况下,以动态,透明的方式给对象添加职责,可以使用装饰模式.  
2.如果不适合使用子类来进行扩展的时候,可以考虑使用装饰模式.
#### 个人看法
一个类需要用到一些辅助的特点时，或者可能说是进行升级版本的，核心是没有变的，就可以使用此模式。
比如经典jdk 里流就是用了此模式，如BufferOutputStream,核心还是一个输出流，为其套上具有缓冲的功能。        
#### 缺点
如果过度使用会创建太多的类。
#### 总结   
1. 继承属于扩展的形式之一，但不是达到弹性设计的最佳方法。
2. 在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码。
3. 组合和委托可用于在运行时动态地加上新的行为。
4. 装饰者模式意味着一群装饰者类，这此类用来包装具体组件。
5. 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。
6. 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得更复杂。

---
### 抽象工厂
> 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
#### 使用场景
1.如果希望一个系统独立于它的产品的创建,组合和表示的时候,换句话书,希望一个系统只是知道产品的接口,而不关心实现的时候.  
2.如果一个系统要由多个产品系列中的一个来配置的时候.换句话说,就是可以,就是可以动态地切换产品簇的时候.  
3.如果强调一系列相关产品的接口,以便联合使用他们的时候  
#### 总结
1. 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。
2. 抽象工厂创建相关的对象家族，而不需要依赖它们的具体类。 


---    
### 工厂方法
> 创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类.
#### 使用场景 
1.客户类不关心使用哪个具体类,只关心该接口所提供的功能.  
2.创建过程比较复杂,例如需要初始化其他关联的资源类,读取配置文件等.  
3.接口有很多具体实现或者抽象类有很多具体子类时,  
4.不希望给客户程序暴露过多的此类的内部结构,隐藏这些细节可以降低耦合度.  
5.优化性能,比如缓存大对象或者初始化比较耗时的对象.     
#### 总结
1. 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。
2. 所有工厂模式都 通过 减少应用程序和具体类之间的依赖促进松耦合
3. 工厂方法允许类将实例化延迟到子类进行。

---        
### 单例模式
> 确保一个类只有一个实例，并提供一个全局访问点
#### 使用场合
当需要控制一个类的实例只能有一个,而且客户只能从一个全局访问点访问它时,可以使用单例模式,这些功能恰好是单例模式要解决的问题.
#### 个人看法
让构造函数私有，再提供个唯一的静态方法让其他类拿到实例，在静态方法中做唯一控制。
#### 总结   
1. 单件模式确保中一个类最多只有一个实例
2. 单件模式也提供访问这个实例的全局点。
3. 在Java中实现单件模式，需要私有的构造器，一个静态方法和一个静态变量
4. 确定在性能和资源上的限制，然后小心地选择适当的方案来实现单件，以解决多纯种的总是
5. 如果使用多个类加载器，可能导致单件失败而创建多个实例
6. 如果使用Jvm1.2或之前的版本，你必须建立单件注册表，以防垃圾收集器将单件回收

---
### 命令模式
> 将请求封装成对象，这可以让你使用不同的请求、队列、或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。
#### 使用场合
当需要将发出的请求的对象 和执行请求的对象解耦的时候，就可以使用命令模式。
#### 个人看法
利用command这个介质让两个互相需要关联调用的对象进行解耦。关注下宏命令（MacroCommand），可以将多个命令进行一次控制。
还有noCommand的意义在于初始化一次状态，而不会使有些没有命令的操作返回null.
#### 总结   
1. 命令模式将发出的对象和执行请求的对象解耦
2. 在被解耦的两者之间是能过命令对象进行沟通的，命令对象封装了接收者和一个或一组动作。
3. 调用者通过调用命令对象的execute（）发出请求，这会使得接收者的动作被调用 。
4. 调用者可以接受命令当做参数，甚至在运行时动态地进行。
5. 命令可以支持撤销，做法是实现一个undo()方法来回到execute（）被执行前的状态。
6. 宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销。
7. 实际操作时，很常见使用"聪明"命令对象，也就是直接实现了请求，而不是将工作委托给接收 者。
8. 命令也可以用来实现日志和事务系统 。





    




 
